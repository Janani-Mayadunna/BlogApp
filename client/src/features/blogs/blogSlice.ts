import { Blog } from "../../interfaces/Blog";
import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit";

import axios from "axios";

/* 

  "slice" typically refers to a slice of application state managed by a Redux slice.
  A slice should have,
      ~ an interface of the shape of the slice's state
      ~ initial state
      ~ action creators
      ~ reducer logic
      ~ selectors 
          - this slice doesn't have any cuz all the state variables are directly accessible
          - All the state variables are directly accessible because they are defined as properties of the BlogState interface

*/

// an interface for everything that belongs to a blog

interface BlogState {
  blogs: Blog[] | null; //to retrieve all blogs
  singleBlog: Blog | null; //to retrieve a single blog
  loading: boolean;
  errors: any;
}

// define initial state

const initialState: BlogState = {
  blogs: [], // initially blogs are gonna be an empty array
  singleBlog: null,
  loading: false,
  errors: null,
};

// actions - processes that gets data from BE

// createAsyncThunk is used to create asynchronous actions to interact with a backend API.
// The getBlogs function created using createAsyncThunk returns a Promise that resolves with the data retrieved from the specified URL endpoint
// If the Promise is rejected, createAsyncThunk will automatically dispatch a failed action with an error payload.
// The generated function dispatches a pending action when it starts, a fulfilled action, and a rejected action.
// Using createAsyncThunk also generates action types and action creators automatically, which reduces the amount of boilerplate code required to manage async actions in Redux.

export const getBlogs = createAsyncThunk<Blog[]>(
  //argument 1 -  a unique identifier string for the action type
  "blogs/getBlogs",

  //argument 2 - a function that performs the API call and returns a Promise with value
  // If the request is successful, the returned data will be dispatched as the action payload.
  async (_, thunkAPI) => {
    try {
      const response = await axios.get("http://localhost:8080/api/blogs");
      return response.data;
    } catch (error) {
      // dispatch a rejected action with the error value as the payload.
      return thunkAPI.rejectWithValue(error);
    }
  }
);

export const getBlogById = createAsyncThunk<Blog, string>(
  "blogs/getBlogById",
  async (id, thunkAPI) => {
    try {
      const response = await axios.get(
        `http://localhost:8080/api/blogs/blog/${id}`
      );
      return response.data;
    } catch (error) {
      return thunkAPI.rejectWithValue(error);
    }
  }
);

export const updateBlog = createAsyncThunk<Blog, Object | any>(
  "blogs/updateBlog",
  async (data, thunkAPI) => {
    try {
      const response = await axios.put(
        `http://localhost:8080/api/blogs/blog/${data._id}`,
        data
      );
      return response.data;
    } catch (error) {
      return thunkAPI.rejectWithValue(error);
    }
  }
);

export const deleteBlog = createAsyncThunk<string, string>(
  "blogs/deleteBlog",
  async (id, thunkAPI) => {
    try {
      const response = await axios.delete(
        `http://localhost:8080/api/blogs/blog/${id}`
      );
      // to reload page when deleted. other method is
      thunkAPI.dispatch(getBlogs());
      return response.data;
    } catch (error) {
      return thunkAPI.rejectWithValue(error);
    }
  }
);

export const createBlog = createAsyncThunk<Blog, Object>(
  "blogs/createBlog",
  async (data, thunkAPI) => {
    try {
      const response = await axios.post(
        "http://localhost:8080/api/blogs/blog",
        data
      );
      thunkAPI.dispatch(getBlogs());
      return response.data;
    } catch (error) {
      return thunkAPI.rejectWithValue(error);
    }
  }
);

// reducers - reduce to a specific state -> changes/manipulates states
// blogSlice object created from createSlice function
export const blogSlice = createSlice({
  name: "blogs",
  initialState,
  // An object containing reducer functions that can be used to update the slice's state directly.
  reducers: {
    // takes in a PayloadAction containing an array of Blog objects, and sets the state.blogs property to that array.
    setBlogs: (state, action: PayloadAction<Blog[]>) => {
      state.blogs = action.payload;
    },
    // takes in an action containing an _id property, and filters out the Blog object with that _id from the state.blogs array.
    filterBlog: (state, action) => {
      state.blogs = state.blogs?.filter((blog) => blog._id !== action.payload)!;
    },
  },
  // An object containing reducer functions that respond to actions generated by other parts of the application, such as async actions
  // defines three functions that handle the different states of an async action named getBlogs, which is defined using the createAsyncThunk function.
  // used to handle the three action states generated by the getBlogs async thunk: pending, fulfilled, and rejected.
  extraReducers: (builder) => {
    builder.addCase(getBlogs.pending, (state) => {
      state.loading = true;
    });
    builder.addCase(getBlogs.fulfilled, (state, action) => {
      state.loading = false;
      state.blogs = action.payload;
    });
    builder.addCase(getBlogs.rejected, (state, action) => {
      state.loading = false;
      state.errors = action.payload;
    });
    builder.addCase(getBlogById.pending, (state) => {
      state.loading = true;
    });
    builder.addCase(getBlogById.fulfilled, (state, action) => {
      state.loading = false;
      state.singleBlog = action.payload;
    });
    builder.addCase(updateBlog.fulfilled, (state, action) => {
      state.loading = false;
      state.singleBlog = action.payload;
    });
    // builder.addCase(deleteBlog.fulfilled, (state, action) => {
    //   state.loading = false;
    //   state.singleBlog = null;
    // });
  },
});

export default blogSlice.reducer;
export const { setBlogs } = blogSlice.actions;
